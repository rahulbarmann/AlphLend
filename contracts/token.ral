Contract TokenVault(tokenHeldId: ByteVec, mut amountHeld: U256, tokenReleasedId: ByteVec, amountToRelease: U256) {
    // Mapping to store the last deposit timestamp for each depositor
    mapping[Address, U256] depositorTimestamp
    
    event TokenReleased(to: Address, amount: U256)
    event DepositRecorded(depositor: Address, timestamp: U256)


    // Initialization function to set the initial amountHeld to zero
    @using(updateFields = true, checkExternalCaller = false)
    pub fn initialize() -> () {
        amountHeld = 0
    }

    // Function to deposit tokens into the vault and record the time
    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true, checkExternalCaller = false)
    pub fn deposit(caller: Address, depositAmount: U256) -> () {
        transferTokenToSelf!(caller, tokenHeldId, depositAmount)
        
        // Update the mutable amountHeld with the new deposit
        amountHeld = amountHeld + depositAmount
        
        // Record the current block timestamp for the caller
        depositorTimestamp.insert!(caller, caller, blockTimeStamp!())
        
        // Emit an event with the depositor's address and timestamp
        emit DepositRecorded(caller, blockTimeStamp!())
    }

    // Function to check if 2 minutes have passed since the last deposit and release tokens if true
    @using(assetsInContract = true, checkExternalCaller = false)
    pub fn releaseIfAllowed(to: Address) -> () {
        // Retrieve the last deposit time for the caller
        assert!(depositorTimestamp.contains!(to), 1)
        let lastDepositTime = depositorTimestamp[to]

        // Check if 2 minutes (120,000 milliseconds) have passed since the last deposit
        assert!(blockTimeStamp!() - lastDepositTime >= 120000, 2)

        // Release tokens if 2 minutes have passed
        transferTokenFromSelf!(to, tokenReleasedId, amountToRelease)

        // Emit event for token release
        emit TokenReleased(to, amountToRelease)
    }
}
